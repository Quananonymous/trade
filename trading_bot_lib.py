# ==============================================================
# TRADING BOT MANAGER - PH·∫¶N 2: BOT MANAGER & MAIN SYSTEM
# ==============================================================

import threading
import time
import requests
from trading_bot_core import *

class BotManager:
    def __init__(self, api_key=None, api_secret=None, telegram_bot_token=None, telegram_chat_id=None):
        self.ws_manager = WebSocketManager()
        self.bots = {}
        self.running = True
        self.start_time = time.time()
        self.user_states = {}
        
        # Cache ƒë·ªÉ t·ªëi ∆∞u hi·ªáu nƒÉng
        self._balance_cache = {"value": None, "timestamp": 0}
        self._positions_cache = {"value": None, "timestamp": 0}
        self.cache_ttl = 30
        
        # Session cho requests
        self.session = requests.Session()
        self.session.mount('https://', requests.adapters.HTTPAdapter(pool_connections=10, pool_maxsize=100, max_retries=3))
        
        self.auto_strategies = {}
        self.last_auto_scan = 0
        self.auto_scan_interval = 600
        
        # Cooldown strategies
        self.strategy_cooldowns = {
            "Reverse 24h": {},
            "Scalping": {},
            "Trend Following": {},
            "Safe Grid": {},
            "Smart Dynamic": {}
        }
        self.cooldown_period = 300
        
        self.api_key = api_key
        self.api_secret = api_secret
        self.telegram_bot_token = telegram_bot_token
        self.telegram_chat_id = telegram_chat_id
        
        if api_key and api_secret:
            self._verify_api_connection()
            self.log("üü¢ H·ªÜ TH·ªêNG BOT TH√îNG MINH ƒê√É KH·ªûI ƒê·ªòNG")
            
            # Kh·ªüi ƒë·ªông Telegram listener
            if self.telegram_bot_token and self.telegram_chat_id:
                self.telegram_thread = threading.Thread(target=self._telegram_listener, daemon=True)
                self.telegram_thread.start()
                
                # G·ª≠i menu ch√†o m·ª´ng sau 2 gi√¢y
                threading.Timer(2.0, lambda: self.send_main_menu(self.telegram_chat_id)).start()
            
            # Auto scan thread
            self.auto_scan_thread = threading.Thread(target=self._auto_scan_loop, daemon=True)
            self.auto_scan_thread.start()
        else:
            self.log("‚ö° BotManager kh·ªüi ƒë·ªông ·ªü ch·∫ø ƒë·ªô kh√¥ng config")

    def _verify_api_connection(self):
        """X√°c minh k·∫øt n·ªëi API Binance"""
        try:
            balance = get_balance(self.api_key, self.api_secret)
            if balance is None:
                self.log("‚ùå L·ªñI: Kh√¥ng th·ªÉ k·∫øt n·ªëi Binance API.")
            else:
                self.log(f"‚úÖ K·∫øt n·ªëi Binance th√†nh c√¥ng! S·ªë d∆∞: {balance:.2f} USDT")
        except Exception as e:
            self.log(f"‚ùå L·ªói x√°c minh API: {str(e)}")

    def log(self, message):
        """Ghi log h·ªá th·ªëng"""
        logger.info(f"[SYSTEM] {message}")
        # Ch·ªâ g·ª≠i log quan tr·ªçng qua Telegram ƒë·ªÉ tr√°nh spam
        if self.telegram_bot_token and self.telegram_chat_id and any(keyword in message for keyword in ["‚úÖ", "‚ùå", "üîÑ", "‚õî", "üéØ"]):
            try:
                send_telegram(f"<b>SYSTEM</b>: {message}", 
                             bot_token=self.telegram_bot_token, 
                             default_chat_id=self.telegram_chat_id)
            except:
                pass

    def send_main_menu(self, chat_id):
        """G·ª≠i menu ch√≠nh"""
        try:
            welcome = (
                "ü§ñ <b>BOT GIAO D·ªäCH FUTURES TH√îNG MINH</b>\n\n"
                "üéØ <b>H·ªÜ TH·ªêNG ƒêA CHI·∫æN L∆Ø·ª¢C + SMART EXIT + BOT ƒê·ªòNG</b>\n\n"
                "üí° <i>Ch·ªçn ch·ª©c nƒÉng t·ª´ menu b√™n d∆∞·ªõi:</i>"
            )
            send_telegram(welcome, chat_id, create_main_menu(),
                         bot_token=self.telegram_bot_token, 
                         default_chat_id=self.telegram_chat_id)
        except Exception as e:
            logger.error(f"L·ªói g·ª≠i menu ch√≠nh: {str(e)}")

    def get_cached_balance(self):
        """L·∫•y s·ªë d∆∞ v·ªõi cache"""
        try:
            current_time = time.time()
            if (self._balance_cache["value"] is None or 
                current_time - self._balance_cache["timestamp"] > self.cache_ttl):
                balance = get_balance(self.api_key, self.api_secret)
                self._balance_cache = {"value": balance, "timestamp": current_time}
            return self._balance_cache["value"]
        except Exception as e:
            logger.error(f"L·ªói l·∫•y s·ªë d∆∞: {str(e)}")
            return None

    def get_cached_positions(self):
        """L·∫•y v·ªã th·∫ø v·ªõi cache"""
        try:
            current_time = time.time()
            if (self._positions_cache["value"] is None or 
                current_time - self._positions_cache["timestamp"] > self.cache_ttl):
                positions = get_positions(api_key=self.api_key, api_secret=self.api_secret)
                self._positions_cache = {"value": positions, "timestamp": current_time}
            return self._positions_cache["value"]
        except Exception as e:
            logger.error(f"L·ªói l·∫•y v·ªã th·∫ø: {str(e)}")
            return []

    def _is_in_cooldown(self, strategy_type, config_key):
        """Ki·ªÉm tra chi·∫øn l∆∞·ª£c c√≥ ƒëang trong cooldown kh√¥ng"""
        if strategy_type not in self.strategy_cooldowns:
            return False
            
        last_cooldown_time = self.strategy_cooldowns[strategy_type].get(config_key)
        if last_cooldown_time is None:
            return False
            
        current_time = time.time()
        if current_time - last_cooldown_time < self.cooldown_period:
            return True
            
        # H·∫øt cooldown, x√≥a kh·ªèi danh s√°ch
        del self.strategy_cooldowns[strategy_type][config_key]
        return False

    def _auto_scan_loop(self):
        """V√≤ng l·∫∑p t·ª± ƒë·ªông qu√©t coin"""
        while self.running:
            try:
                current_time = time.time()
                
                # Ki·ªÉm tra bot ƒë·ªông c·∫ßn t√¨m coin m·ªõi
                bot_removed = False
                for bot_id, bot in list(self.bots.items()):
                    if hasattr(bot, 'should_be_removed') and bot.should_be_removed:
                        self.stop_bot(bot_id)
                        bot_removed = True
                
                # Qu√©t auto strategies n·∫øu ƒë·ªß th·ªùi gian ho·∫∑c c√≥ bot b·ªã x√≥a
                if (current_time - self.last_auto_scan > self.auto_scan_interval or 
                    bot_removed or 
                    any(not bot.position_open and hasattr(bot, 'dynamic_mode') and bot.dynamic_mode for bot in self.bots.values())):
                    
                    self._scan_auto_strategies()
                    self.last_auto_scan = current_time
                
                time.sleep(30)
                
            except Exception as e:
                self.log(f"‚ùå L·ªói auto scan: {str(e)}")
                time.sleep(60)

    def _scan_auto_strategies(self):
        """Qu√©t v√† b·ªï sung coin cho chi·∫øn thu·∫≠t t·ª± ƒë·ªông"""
        if not self.auto_strategies:
            return
            
        self.log("üîÑ ƒêang qu√©t coin cho c√°c c·∫•u h√¨nh t·ª± ƒë·ªông...")
        
        for strategy_key, strategy_config in self.auto_strategies.items():
            try:
                strategy_type = strategy_config['strategy_type']
                
                # Ki·ªÉm tra cooldown
                if self._is_in_cooldown(strategy_type, strategy_key):
                    continue
                
                coin_manager = CoinManager()
                current_bots_count = coin_manager.count_bots_by_config(strategy_key)
                
                if current_bots_count < 2:
                    self.log(f"üîÑ {strategy_type}: ƒëang c√≥ {current_bots_count}/2 bot, t√¨m th√™m coin...")
                    
                    qualified_symbols = self._find_qualified_symbols(strategy_type, strategy_config, strategy_key)
                    
                    added_count = 0
                    for symbol in qualified_symbols:
                        if added_count >= (2 - current_bots_count):
                            break
                            
                        bot_id = f"{symbol}_{strategy_key}"
                        if bot_id not in self.bots:
                            success = self._create_auto_bot(symbol, strategy_type, strategy_config)
                            if success:
                                added_count += 1
                                time.sleep(0.5)
                    
                    if added_count > 0:
                        self.log(f"‚úÖ {strategy_type}: ƒë√£ th√™m {added_count} bot m·ªõi")
                        
            except Exception as e:
                self.log(f"‚ùå L·ªói qu√©t {strategy_type}: {str(e)}")

    def _find_qualified_symbols(self, strategy_type, config, strategy_key):
        """T√¨m coin ph√π h·ª£p cho chi·∫øn l∆∞·ª£c"""
        try:
            leverage = config['leverage']
            threshold = config.get('threshold', 30)
            volatility = config.get('volatility', 3)
            grid_levels = config.get('grid_levels', 5)
            
            qualified_symbols = get_qualified_symbols(
                self.api_key, self.api_secret, strategy_type, leverage,
                threshold, volatility, grid_levels, 
                max_candidates=15,
                final_limit=2,
                strategy_key=strategy_key
            )
            
            return qualified_symbols
            
        except Exception as e:
            self.log(f"‚ùå L·ªói t√¨m coin: {str(e)}")
            return []

    def _create_auto_bot(self, symbol, strategy_type, config):
        """T·∫°o bot t·ª± ƒë·ªông"""
        try:
            leverage = config['leverage']
            percent = config['percent']
            tp = config['tp']
            sl = config['sl']
            strategy_key = config['strategy_key']
            smart_exit_config = config.get('smart_exit_config', {})
            dynamic_mode = config.get('dynamic_mode', True)
            
            bot_class = {
                "Reverse 24h": Reverse_24h_Bot,
                "Scalping": Scalping_Bot,
                "Safe Grid": Safe_Grid_Bot,
                "Trend Following": Trend_Following_Bot,
                "Smart Dynamic": SmartDynamicBot
            }.get(strategy_type)
            
            if not bot_class:
                return False
            
            # Ki·ªÉm tra symbol c√≥ t·ªìn t·∫°i kh√¥ng
            current_price = get_current_price(symbol)
            if current_price <= 0:
                return False
            
            if strategy_type == "Reverse 24h":
                threshold = config.get('threshold', 30)
                bot = bot_class(symbol, leverage, percent, tp, sl, self.ws_manager,
                              self.api_key, self.api_secret, self.telegram_bot_token, 
                              self.telegram_chat_id, threshold, strategy_key, smart_exit_config, dynamic_mode)
            elif strategy_type == "Safe Grid":
                grid_levels = config.get('grid_levels', 5)
                bot = bot_class(symbol, leverage, percent, tp, sl, self.ws_manager,
                              self.api_key, self.api_secret, self.telegram_bot_token,
                              self.telegram_chat_id, grid_levels, strategy_key, smart_exit_config, dynamic_mode)
            else:
                bot = bot_class(symbol, leverage, percent, tp, sl, self.ws_manager,
                              self.api_key, self.api_secret, self.telegram_bot_token,
                              self.telegram_chat_id, strategy_key, smart_exit_config, dynamic_mode)
            
            bot_id = f"{symbol}_{strategy_key}"
            self.bots[bot_id] = bot
            return True
            
        except Exception as e:
            self.log(f"‚ùå L·ªói t·∫°o bot {symbol}: {str(e)}")
            return False

    def add_bot(self, symbol, lev, percent, tp, sl, strategy_type, **kwargs):
        """Th√™m bot m·ªõi - PHI√äN B·∫¢N ƒê√É S·ª¨A L·ªñI"""
        try:
            # Validation
            if sl == 0:
                sl = None
                
            if not self.api_key or not self.api_secret:
                self.log("‚ùå Ch∆∞a thi·∫øt l·∫≠p API Key")
                return False
            
            # Test connection
            test_balance = self.get_cached_balance()
            if test_balance is None:
                self.log("‚ùå L·ªñI: Kh√¥ng th·ªÉ k·∫øt n·ªëi Binance")
                return False
            
            smart_exit_config = kwargs.get('smart_exit_config', {})
            dynamic_mode = kwargs.get('dynamic_mode', False)
            threshold = kwargs.get('threshold')
            volatility = kwargs.get('volatility')
            grid_levels = kwargs.get('grid_levels')
            
            # X·ª≠ l√Ω theo t·ª´ng lo·∫°i bot
            if strategy_type == "Smart Dynamic":
                return self._create_smart_dynamic_bot(lev, percent, tp, sl, smart_exit_config, dynamic_mode)
            elif dynamic_mode and strategy_type in ["Reverse 24h", "Scalping", "Safe Grid", "Trend Following"]:
                return self._create_dynamic_bot(strategy_type, lev, percent, tp, sl, smart_exit_config, threshold, volatility, grid_levels)
            else:
                return self._create_static_bot(symbol, strategy_type, lev, percent, tp, sl, smart_exit_config)
                
        except Exception as e:
            self.log(f"‚ùå L·ªói nghi√™m tr·ªçng trong add_bot: {str(e)}")
            return False

    def _create_smart_dynamic_bot(self, lev, percent, tp, sl, smart_exit_config, dynamic_mode):
        """T·∫°o bot ƒë·ªông th√¥ng minh"""
        try:
            strategy_key = f"SmartDynamic_{lev}_{percent}_{tp}_{sl}"
            
            if self._is_in_cooldown("Smart Dynamic", strategy_key):
                self.log(f"‚è∞ Smart Dynamic: ƒëang trong cooldown")
                return False
            
            self.auto_strategies[strategy_key] = {
                'strategy_type': "Smart Dynamic",
                'leverage': lev,
                'percent': percent,
                'tp': tp,
                'sl': sl,
                'strategy_key': strategy_key,
                'smart_exit_config': smart_exit_config,
                'dynamic_mode': True
            }
            
            qualified_symbols = self._find_qualified_symbols(
                "Smart Dynamic", self.auto_strategies[strategy_key], strategy_key
            )
            
            success_count = 0
            for symbol in qualified_symbols:
                bot_id = f"{symbol}_{strategy_key}"
                if bot_id not in self.bots:
                    success = self._create_auto_bot(symbol, "Smart Dynamic", self.auto_strategies[strategy_key])
                    if success:
                        success_count += 1
                        if success_count >= 2:
                            break
            
            if success_count > 0:
                success_msg = f"‚úÖ ƒê√É T·∫†O {success_count} BOT ƒê·ªòNG TH√îNG MINH"
                self.log(success_msg)
                return True
            else:
                self.log("‚ö†Ô∏è Smart Dynamic: ch∆∞a t√¨m th·∫•y coin ph√π h·ª£p")
                return False
                
        except Exception as e:
            self.log(f"‚ùå L·ªói t·∫°o Smart Dynamic bot: {str(e)}")
            return False

    def _create_dynamic_bot(self, strategy_type, lev, percent, tp, sl, smart_exit_config, threshold, volatility, grid_levels):
        """T·∫°o bot ƒë·ªông cho c√°c chi·∫øn l∆∞·ª£c"""
        try:
            strategy_key = f"{strategy_type}_{lev}_{percent}_{tp}_{sl}"
            
            if strategy_type == "Reverse 24h":
                strategy_key += f"_th{threshold or 30}"
            elif strategy_type == "Scalping":
                strategy_key += f"_vol{volatility or 3}"
            elif strategy_type == "Safe Grid":
                strategy_key += f"_grid{grid_levels or 5}"
            
            if self._is_in_cooldown(strategy_type, strategy_key):
                self.log(f"‚è∞ {strategy_type}: ƒëang trong cooldown")
                return False
            
            config = {
                'strategy_type': strategy_type,
                'leverage': lev,
                'percent': percent,
                'tp': tp,
                'sl': sl,
                'strategy_key': strategy_key,
                'smart_exit_config': smart_exit_config,
                'dynamic_mode': True
            }
            
            if threshold: config['threshold'] = threshold
            if volatility: config['volatility'] = volatility
            if grid_levels: config['grid_levels'] = grid_levels
            
            self.auto_strategies[strategy_key] = config
            
            qualified_symbols = self._find_qualified_symbols(strategy_type, config, strategy_key)
            
            success_count = 0
            for symbol in qualified_symbols:
                bot_id = f"{symbol}_{strategy_key}"
                if bot_id not in self.bots:
                    success = self._create_auto_bot(symbol, strategy_type, config)
                    if success:
                        success_count += 1
                        if success_count >= 2:
                            break
            
            if success_count > 0:
                success_msg = f"‚úÖ ƒê√É T·∫†O {success_count} BOT {strategy_type}"
                self.log(success_msg)
                return True
            else:
                self.log(f"‚ö†Ô∏è {strategy_type}: ch∆∞a t√¨m th·∫•y coin ph√π h·ª£p")
                return False
                
        except Exception as e:
            self.log(f"‚ùå L·ªói t·∫°o {strategy_type} bot: {str(e)}")
            return False

    def _create_static_bot(self, symbol, strategy_type, lev, percent, tp, sl, smart_exit_config):
        """T·∫°o bot tƒ©nh"""
        try:
            symbol = symbol.upper() if symbol else "BTCUSDT"
            bot_id = f"{symbol}_{strategy_type}"
            
            if bot_id in self.bots:
                self.log(f"‚ö†Ô∏è ƒê√£ c√≥ bot {strategy_type} cho {symbol}")
                return False
            
            bot_class = {
                "RSI/EMA Recursive": RSI_EMA_Bot,
                "EMA Crossover": EMA_Crossover_Bot,
                "Reverse 24h": Reverse_24h_Bot,
                "Trend Following": Trend_Following_Bot,
                "Scalping": Scalping_Bot,
                "Safe Grid": Safe_Grid_Bot
            }.get(strategy_type)
            
            if not bot_class:
                self.log(f"‚ùå Chi·∫øn l∆∞·ª£c {strategy_type} kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£")
                return False
            
            # Validate symbol
            current_price = get_current_price(symbol)
            if current_price <= 0:
                self.log(f"‚ùå {symbol}: kh√¥ng l·∫•y ƒë∆∞·ª£c gi√°")
                return False
            
            if strategy_type == "Reverse 24h":
                bot = bot_class(symbol, lev, percent, tp, sl, self.ws_manager,
                              self.api_key, self.api_secret, self.telegram_bot_token,
                              self.telegram_chat_id, threshold=30, smart_exit_config=smart_exit_config)
            elif strategy_type == "Safe Grid":
                bot = bot_class(symbol, lev, percent, tp, sl, self.ws_manager,
                              self.api_key, self.api_secret, self.telegram_bot_token,
                              self.telegram_chat_id, grid_levels=5, smart_exit_config=smart_exit_config)
            else:
                bot = bot_class(symbol, lev, percent, tp, sl, self.ws_manager,
                              self.api_key, self.api_secret, self.telegram_bot_token,
                              self.telegram_chat_id, smart_exit_config=smart_exit_config)
            
            self.bots[bot_id] = bot
            self.log(f"‚úÖ ƒê√£ th√™m bot {strategy_type}: {symbol}")
            return True
            
        except Exception as e:
            self.log(f"‚ùå L·ªói t·∫°o bot tƒ©nh {symbol}: {str(e)}")
            return False

    def stop_bot(self, bot_id):
        """D·ª´ng bot c·ª• th·ªÉ"""
        bot = self.bots.get(bot_id)
        if bot:
            try:
                bot.stop()
                # Th√™m cooldown n·∫øu l√† bot ƒë·ªông
                if hasattr(bot, 'config_key') and bot.config_key and bot.strategy_name in self.strategy_cooldowns:
                    self.strategy_cooldowns[bot.strategy_name][bot.config_key] = time.time()
                
                del self.bots[bot_id]
                # Clear cache
                self._positions_cache = {"value": None, "timestamp": 0}
                self.log(f"‚õî ƒê√£ d·ª´ng bot {bot_id}")
                return True
            except Exception as e:
                self.log(f"‚ùå L·ªói khi d·ª´ng bot {bot_id}: {str(e)}")
        return False

    def stop_all(self):
        """D·ª´ng to√†n b·ªô h·ªá th·ªëng"""
        self.log("‚õî ƒêang d·ª´ng t·∫•t c·∫£ bot...")
        self.running = False
        for bot_id in list(self.bots.keys()):
            self.stop_bot(bot_id)
        self.ws_manager.stop()
        self.session.close()
        self.log("üî¥ H·ªá th·ªëng ƒë√£ d·ª´ng ho√†n to√†n")

    def _telegram_listener(self):
        """Listener Telegram - ƒê√É S·ª¨A L·ªñI"""
        last_update_id = 0
        error_count = 0
        
        self.log("üîó Telegram listener ƒëang kh·ªüi ƒë·ªông...")
        
        while self.running and self.telegram_bot_token and self.telegram_chat_id:
            try:
                url = f"https://api.telegram.org/bot{self.telegram_bot_token}/getUpdates"
                params = {
                    "offset": last_update_id + 1,
                    "timeout": 30,
                    "allowed_updates": ["message"]
                }
                
                response = self.session.get(url, params=params, timeout=35)
                
                if response.status_code == 200:
                    data = response.json()
                    error_count = 0
                    
                    if data.get('ok') and data.get('result'):
                        for update in data['result']:
                            update_id = update['update_id']
                            message = update.get('message', {})
                            chat_id = str(message.get('chat', {}).get('id'))
                            text = message.get('text', '').strip()
                            
                            if chat_id == self.telegram_chat_id and text:
                                if update_id > last_update_id:
                                    last_update_id = update_id
                                    self._handle_telegram_message(chat_id, text)
                else:
                    error_count += 1
                    if error_count > 5:
                        self.log("‚ö†Ô∏è Qu√° nhi·ªÅu l·ªói Telegram, t·∫°m d·ª´ng 60s")
                        time.sleep(60)
                        error_count = 0
                    else:
                        time.sleep(10)
                
            except requests.exceptions.Timeout:
                continue
            except Exception as e:
                error_count += 1
                logger.error(f"L·ªói Telegram listener: {str(e)}")
                time.sleep(10)

    def _handle_telegram_message(self, chat_id, text):
        """X·ª≠ l√Ω tin nh·∫Øn Telegram - PHI√äN B·∫¢N ƒê·∫¶Y ƒê·ª¶"""
        try:
            user_state = self.user_states.get(chat_id, {})
            current_step = user_state.get('step')
            
            # X·ª≠ l√Ω h·ªßy b·ªè ·ªü m·ªçi b∆∞·ªõc
            if text == '‚ùå H·ªßy b·ªè':
                self.user_states[chat_id] = {}
                send_telegram("‚ùå ƒê√£ h·ªßy thao t√°c", chat_id, create_main_menu(),
                            self.telegram_bot_token, self.telegram_chat_id)
                return
            
            # X·ª≠ l√Ω theo t·ª´ng b∆∞·ªõc
            step_handlers = {
                'waiting_bot_mode': self._handle_bot_mode,
                'waiting_strategy': self._handle_strategy,
                'waiting_exit_strategy': self._handle_exit_strategy,
                'waiting_smart_config': self._handle_smart_config,
                'waiting_threshold': self._handle_threshold,
                'waiting_volatility': self._handle_volatility,
                'waiting_grid_levels': self._handle_grid_levels,
                'waiting_symbol': self._handle_symbol,
                'waiting_leverage': self._handle_leverage,
                'waiting_percent': self._handle_percent,
                'waiting_tp': self._handle_tp,
                'waiting_sl': self._handle_sl
            }
            
            if current_step in step_handlers:
                step_handlers[current_step](chat_id, text, user_state)
                return
            
            # X·ª≠ l√Ω l·ªánh ch√≠nh
            command_handlers = {
                "‚ûï Th√™m Bot": lambda: self._handle_add_bot(chat_id),
                "üìä Danh s√°ch Bot": lambda: self._handle_list_bots(chat_id),
                "‚õî D·ª´ng Bot": lambda: self._handle_stop_bot(chat_id),
                "üí∞ S·ªë d∆∞": lambda: self._handle_balance(chat_id),
                "üìà V·ªã th·∫ø": lambda: self._handle_positions(chat_id),
                "üéØ Chi·∫øn l∆∞·ª£c": lambda: self._handle_strategies(chat_id),
                "‚öôÔ∏è C·∫•u h√¨nh": lambda: self._handle_config(chat_id)
            }
            
            if text in command_handlers:
                command_handlers[text]()
            elif text.startswith("‚õî "):
                self._handle_stop_specific_bot(chat_id, text)
            else:
                self.send_main_menu(chat_id)
                
        except Exception as e:
            logger.error(f"L·ªói x·ª≠ l√Ω Telegram: {str(e)}")
            send_telegram("‚ùå C√≥ l·ªói x·∫£y ra, vui l√≤ng th·ª≠ l·∫°i", chat_id, create_main_menu(),
                         self.telegram_bot_token, self.telegram_chat_id)

    # ========== C√ÅC HANDLER CHO T·ª™NG B∆Ø·ªöC ==========

    def _handle_add_bot(self, chat_id):
        """B·∫Øt ƒë·∫ßu th√™m bot"""
        self.user_states[chat_id] = {'step': 'waiting_bot_mode'}
        balance = self.get_cached_balance()
        
        if balance is None:
            send_telegram("‚ùå L·ªñI K·∫æT N·ªêI BINANCE", chat_id, create_main_menu(),
                         self.telegram_bot_token, self.telegram_chat_id)
            self.user_states[chat_id] = {}
            return
        
        send_telegram(f"üí∞ S·ªë d∆∞: {balance:.2f} USDT\n\nCh·ªçn ch·∫ø ƒë·ªô bot:", chat_id,
                     create_bot_mode_keyboard(), self.telegram_bot_token, self.telegram_chat_id)

    def _handle_bot_mode(self, chat_id, text, user_state):
        if text in ["ü§ñ Bot Tƒ©nh - Coin c·ª• th·ªÉ", "üîÑ Bot ƒê·ªông - T·ª± t√¨m coin"]:
            user_state['dynamic_mode'] = (text == "üîÑ Bot ƒê·ªông - T·ª± t√¨m coin")
            user_state['step'] = 'waiting_strategy'
            
            mode_text = "ƒê·ªòNG - T·ª± t√¨m coin" if user_state['dynamic_mode'] else "Tƒ®NH - Coin c·ªë ƒë·ªãnh"
            send_telegram(f"‚úÖ ƒê√£ ch·ªçn: {mode_text}\n\nCh·ªçn chi·∫øn l∆∞·ª£c:", chat_id,
                         create_strategy_keyboard(), self.telegram_bot_token, self.telegram_chat_id)
            self.user_states[chat_id] = user_state

    def _handle_strategy(self, chat_id, text, user_state):
        strategy_map = {
            "ü§ñ RSI/EMA Recursive": "RSI/EMA Recursive",
            "üìä EMA Crossover": "EMA Crossover", 
            "üéØ Reverse 24h": "Reverse 24h",
            "üìà Trend Following": "Trend Following",
            "‚ö° Scalping": "Scalping",
            "üõ°Ô∏è Safe Grid": "Safe Grid",
            "üîÑ Bot ƒê·ªông Th√¥ng Minh": "Smart Dynamic"
        }
        
        if text in strategy_map:
            strategy = strategy_map[text]
            user_state['strategy'] = strategy
            
            # Smart Dynamic lu√¥n l√† bot ƒë·ªông
            if strategy == "Smart Dynamic":
                user_state['dynamic_mode'] = True
            
            user_state['step'] = 'waiting_exit_strategy'
            
            mode_text = "ƒê·ªòNG" if user_state.get('dynamic_mode') else "Tƒ®NH"
            send_telegram(f"‚úÖ Chi·∫øn l∆∞·ª£c: {strategy}\nCh·∫ø ƒë·ªô: {mode_text}\n\nCh·ªçn chi·∫øn l∆∞·ª£c tho√°t l·ªánh:", chat_id,
                         create_exit_strategy_keyboard(), self.telegram_bot_token, self.telegram_chat_id)
            self.user_states[chat_id] = user_state

    def _handle_exit_strategy(self, chat_id, text, user_state):
        exit_configs = {
            "üîÑ Tho√°t l·ªánh th√¥ng minh": {'step': 'waiting_smart_config', 'config': {}},
            "‚ö° Tho√°t l·ªánh c∆° b·∫£n": {'step': None, 'config': {
                'enable_trailing': True, 'enable_time_exit': True, 'enable_support_resistance': False
            }},
            "üéØ Ch·ªâ TP/SL c·ªë ƒë·ªãnh": {'step': None, 'config': {
                'enable_trailing': False, 'enable_time_exit': False, 'enable_support_resistance': False
            }}
        }
        
        if text in exit_configs:
            config_info = exit_configs[text]
            user_state['smart_exit_config'] = config_info['config']
            
            if config_info['step']:
                user_state['step'] = config_info['step']
                send_telegram("Ch·ªçn c·∫•u h√¨nh Smart Exit:", chat_id,
                             create_smart_exit_config_keyboard(), self.telegram_bot_token, self.telegram_chat_id)
            else:
                self._continue_bot_creation(chat_id, user_state)
            
            self.user_states[chat_id] = user_state

    def _handle_smart_config(self, chat_id, text, user_state):
        smart_configs = {
            "Trailing: 30/15": {'enable_trailing': True, 'trailing_activation': 30, 'trailing_distance': 15},
            "Trailing: 50/20": {'enable_trailing': True, 'trailing_activation': 50, 'trailing_distance': 20},
            "Time Exit: 4h": {'enable_time_exit': True, 'max_hold_time': 4},
            "Time Exit: 8h": {'enable_time_exit': True, 'max_hold_time': 8},
            "K·∫øt h·ª£p Full": {'enable_trailing': True, 'enable_time_exit': True, 'enable_support_resistance': True},
            "C∆° b·∫£n": {'enable_trailing': True, 'enable_time_exit': True}
        }
        
        if text in smart_configs:
            user_state['smart_exit_config'].update(smart_configs[text])
            self._continue_bot_creation(chat_id, user_state)

    def _handle_threshold(self, chat_id, text, user_state):
        try:
            threshold = float(text)
            user_state['threshold'] = threshold
            user_state['step'] = 'waiting_leverage'
            send_telegram(f"‚úÖ Ng∆∞·ª°ng: {threshold}%\n\nCh·ªçn ƒë√≤n b·∫©y:", chat_id,
                         create_leverage_keyboard(), self.telegram_bot_token, self.telegram_chat_id)
            self.user_states[chat_id] = user_state
        except ValueError:
            send_telegram("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá", chat_id,
                         create_threshold_keyboard(), self.telegram_bot_token, self.telegram_chat_id)

    def _handle_volatility(self, chat_id, text, user_state):
        try:
            volatility = float(text)
            user_state['volatility'] = volatility
            user_state['step'] = 'waiting_leverage'
            send_telegram(f"‚úÖ Bi·∫øn ƒë·ªông: {volatility}%\n\nCh·ªçn ƒë√≤n b·∫©y:", chat_id,
                         create_leverage_keyboard(), self.telegram_bot_token, self.telegram_chat_id)
            self.user_states[chat_id] = user_state
        except ValueError:
            send_telegram("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá", chat_id,
                         create_volatility_keyboard(), self.telegram_bot_token, self.telegram_chat_id)

    def _handle_grid_levels(self, chat_id, text, user_state):
        try:
            grid_levels = int(text)
            user_state['grid_levels'] = grid_levels
            user_state['step'] = 'waiting_leverage'
            send_telegram(f"‚úÖ S·ªë l·ªánh: {grid_levels}\n\nCh·ªçn ƒë√≤n b·∫©y:", chat_id,
                         create_leverage_keyboard(), self.telegram_bot_token, self.telegram_chat_id)
            self.user_states[chat_id] = user_state
        except ValueError:
            send_telegram("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá", chat_id,
                         create_grid_levels_keyboard(), self.telegram_bot_token, self.telegram_chat_id)

    def _handle_symbol(self, chat_id, text, user_state):
        symbol = text.upper()
        user_state['symbol'] = symbol
        user_state['step'] = 'waiting_leverage'
        send_telegram(f"‚úÖ Coin: {symbol}\n\nCh·ªçn ƒë√≤n b·∫©y:", chat_id,
                     create_leverage_keyboard(), self.telegram_bot_token, self.telegram_chat_id)
        self.user_states[chat_id] = user_state

    def _handle_leverage(self, chat_id, text, user_state):
        try:
            leverage = int(text.replace('x', '').strip())
            if 1 <= leverage <= 100:
                user_state['leverage'] = leverage
                user_state['step'] = 'waiting_percent'
                send_telegram(f"‚úÖ ƒê√≤n b·∫©y: {leverage}x\n\nCh·ªçn % s·ªë d∆∞:", chat_id,
                             create_percent_keyboard(), self.telegram_bot_token, self.telegram_chat_id)
                self.user_states[chat_id] = user_state
            else:
                send_telegram("‚ö†Ô∏è ƒê√≤n b·∫©y ph·∫£i t·ª´ 1-100x", chat_id,
                             create_leverage_keyboard(), self.telegram_bot_token, self.telegram_chat_id)
        except ValueError:
            send_telegram("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá", chat_id,
                         create_leverage_keyboard(), self.telegram_bot_token, self.telegram_chat_id)

    def _handle_percent(self, chat_id, text, user_state):
        try:
            percent = float(text)
            if 0 < percent <= 100:
                user_state['percent'] = percent
                user_state['step'] = 'waiting_tp'
                send_telegram(f"‚úÖ S·ªë d∆∞: {percent}%\n\nCh·ªçn Take Profit (%):", chat_id,
                             create_tp_keyboard(), self.telegram_bot_token, self.telegram_chat_id)
                self.user_states[chat_id] = user_state
            else:
                send_telegram("‚ö†Ô∏è % s·ªë d∆∞ ph·∫£i t·ª´ 0.1-100", chat_id,
                             create_percent_keyboard(), self.telegram_bot_token, self.telegram_chat_id)
        except ValueError:
            send_telegram("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá", chat_id,
                         create_percent_keyboard(), self.telegram_bot_token, self.telegram_chat_id)

    def _handle_tp(self, chat_id, text, user_state):
        try:
            tp = float(text)
            if tp >= 0:
                user_state['tp'] = tp
                user_state['step'] = 'waiting_sl'
                send_telegram(f"‚úÖ TP: {tp}%\n\nCh·ªçn Stop Loss (%):", chat_id,
                             create_sl_keyboard(), self.telegram_bot_token, self.telegram_chat_id)
                self.user_states[chat_id] = user_state
            else:
                send_telegram("‚ö†Ô∏è TP ph·∫£i >= 0", chat_id,
                             create_tp_keyboard(), self.telegram_bot_token, self.telegram_chat_id)
        except ValueError:
            send_telegram("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá", chat_id,
                         create_tp_keyboard(), self.telegram_bot_token, self.telegram_chat_id)

    def _handle_sl(self, chat_id, text, user_state):
        try:
            sl = float(text)
            if sl >= 0:
                user_state['sl'] = sl
                
                # T·∫°o bot cu·ªëi c√πng
                success = self._create_bot_from_state(chat_id, user_state)
                
                if success:
                    strategy = user_state.get('strategy')
                    leverage = user_state.get('leverage')
                    percent = user_state.get('percent')
                    dynamic_mode = user_state.get('dynamic_mode', False)
                    
                    success_msg = (
                        f"‚úÖ <b>BOT ƒê√É ƒê∆Ø·ª¢C T·∫†O TH√ÄNH C√îNG!</b>\n\n"
                        f"ü§ñ {strategy}\n"
                        f"üí∞ {leverage}x | {percent}% s·ªë d∆∞\n"
                        f"üéØ TP: {user_state.get('tp')}% | SL: {sl}%\n"
                        f"üîß Ch·∫ø ƒë·ªô: {'ƒê·ªòNG' if dynamic_mode else 'Tƒ®NH'}\n\n"
                        f"üìà Theo d√µi trong danh s√°ch bot!"
                    )
                else:
                    success_msg = "‚ùå <b>L·ªñI T·∫†O BOT!</b>\n\nKi·ªÉm tra API Key v√† s·ªë d∆∞!"
                
                send_telegram(success_msg, chat_id, create_main_menu(),
                            self.telegram_bot_token, self.telegram_chat_id)
                
                # Reset state
                self.user_states[chat_id] = {}
                
            else:
                send_telegram("‚ö†Ô∏è SL ph·∫£i >= 0", chat_id,
                             create_sl_keyboard(), self.telegram_bot_token, self.telegram_chat_id)
        except ValueError:
            send_telegram("‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá", chat_id,
                         create_sl_keyboard(), self.telegram_bot_token, self.telegram_chat_id)

    def _continue_bot_creation(self, chat_id, user_state):
        """Ti·∫øp t·ª•c quy tr√¨nh t·∫°o bot"""
        strategy = user_state.get('strategy')
        dynamic_mode = user_state.get('dynamic_mode', False)
        
        next_steps = {
            ("Reverse 24h", True): 'waiting_threshold',
            ("Scalping", True): 'waiting_volatility',
            ("Safe Grid", True): 'waiting_grid_levels',
        }
        
        next_step = next_steps.get((strategy, dynamic_mode), 
                                 'waiting_symbol' if not dynamic_mode else 'waiting_leverage')
        
        user_state['step'] = next_step
        
        step_messages = {
            'waiting_threshold': ("Ch·ªçn ng∆∞·ª°ng bi·∫øn ƒë·ªông (%):", create_threshold_keyboard()),
            'waiting_volatility': ("Ch·ªçn bi·∫øn ƒë·ªông t·ªëi thi·ªÉu (%):", create_volatility_keyboard()),
            'waiting_grid_levels': ("Ch·ªçn s·ªë l·ªánh grid:", create_grid_levels_keyboard()),
            'waiting_symbol': ("Ch·ªçn c·∫∑p coin:", create_symbols_keyboard(strategy)),
            'waiting_leverage': ("Ch·ªçn ƒë√≤n b·∫©y:", create_leverage_keyboard(strategy))
        }
        
        if next_step in step_messages:
            message, keyboard = step_messages[next_step]
            send_telegram(message, chat_id, keyboard, self.telegram_bot_token, self.telegram_chat_id)
        
        self.user_states[chat_id] = user_state

    def _create_bot_from_state(self, chat_id, user_state):
        """T·∫°o bot t·ª´ state"""
        try:
            return self.add_bot(
                symbol=user_state.get('symbol'),
                lev=user_state.get('leverage'),
                percent=user_state.get('percent'),
                tp=user_state.get('tp'),
                sl=user_state.get('sl'),
                strategy_type=user_state.get('strategy'),
                dynamic_mode=user_state.get('dynamic_mode', False),
                smart_exit_config=user_state.get('smart_exit_config', {}),
                threshold=user_state.get('threshold'),
                volatility=user_state.get('volatility'),
                grid_levels=user_state.get('grid_levels')
            )
        except Exception as e:
            self.log(f"‚ùå L·ªói t·∫°o bot t·ª´ state: {str(e)}")
            return False

    # ========== C√ÅC HANDLER L·ªÜNH CH√çNH ==========

    def _handle_list_bots(self, chat_id):
        if not self.bots:
            send_telegram("ü§ñ Kh√¥ng c√≥ bot n√†o ƒëang ch·∫°y", chat_id,
                         bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)
        else:
            message = "ü§ñ <b>DANH S√ÅCH BOT ƒêANG CH·∫†Y</b>\n\n"
            for bot_id, bot in self.bots.items():
                status = "üü¢ M·ªü" if bot.position_open else "üü° Ch·ªù"
                mode = "üîÑ ƒê·ªông" if getattr(bot, 'dynamic_mode', False) else "ü§ñ Tƒ©nh"
                message += f"üîπ {bot_id} | {status} | {mode}\n"
            
            message += f"\nüìä T·ªïng s·ªë: {len(self.bots)} bot"
            send_telegram(message, chat_id,
                         bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)

    def _handle_stop_bot(self, chat_id):
        if not self.bots:
            send_telegram("ü§ñ Kh√¥ng c√≥ bot n√†o ƒëang ch·∫°y", chat_id,
                         bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)
        else:
            keyboard = []
            for bot_id in self.bots.keys():
                keyboard.append([{"text": f"‚õî {bot_id}"}])
            keyboard.append([{"text": "‚ùå H·ªßy b·ªè"}])
            
            send_telegram("‚õî <b>CH·ªåN BOT ƒê·ªÇ D·ª™NG</b>", chat_id,
                         {"keyboard": keyboard, "resize_keyboard": True, "one_time_keyboard": True},
                         self.telegram_bot_token, self.telegram_chat_id)

    def _handle_stop_specific_bot(self, chat_id, text):
        bot_id = text.replace("‚õî ", "").strip()
        if self.stop_bot(bot_id):
            send_telegram(f"‚õî ƒê√£ d·ª´ng bot {bot_id}", chat_id, create_main_menu(),
                         self.telegram_bot_token, self.telegram_chat_id)
        else:
            send_telegram(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y bot {bot_id}", chat_id, create_main_menu(),
                         self.telegram_bot_token, self.telegram_chat_id)

    def _handle_balance(self, chat_id):
        balance = self.get_cached_balance()
        if balance is None:
            send_telegram("‚ùå <b>L·ªñI K·∫æT N·ªêI BINANCE</b>", chat_id,
                         bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)
        else:
            send_telegram(f"üí∞ <b>S·ªê D∆Ø KH·∫¢ D·ª§NG</b>: {balance:.2f} USDT", chat_id,
                         bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)

    def _handle_positions(self, chat_id):
        positions = self.get_cached_positions()
        if not positions:
            send_telegram("üì≠ Kh√¥ng c√≥ v·ªã th·∫ø n√†o ƒëang m·ªü", chat_id,
                         bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)
        else:
            message = "üìà <b>V·ªä TH·∫æ ƒêANG M·ªû</b>\n\n"
            for pos in positions:
                position_amt = float(pos.get('positionAmt', 0))
                if position_amt != 0:
                    symbol = pos.get('symbol', 'UNKNOWN')
                    entry = float(pos.get('entryPrice', 0))
                    side = "LONG" if position_amt > 0 else "SHORT"
                    pnl = float(pos.get('unRealizedProfit', 0))
                    
                    message += (
                        f"üîπ {symbol} | {side}\n"
                        f"üìä Kh·ªëi l∆∞·ª£ng: {abs(position_amt):.4f}\n"
                        f"üè∑Ô∏è Gi√° v√†o: {entry:.4f}\n"
                        f"üí∞ PnL: {pnl:.2f} USDT\n\n"
                    )
            
            send_telegram(message, chat_id,
                         bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)

    def _handle_strategies(self, chat_id):
        strategy_info = "üéØ <b>DANH S√ÅCH CHI·∫æN L∆Ø·ª¢C</b>\n\n" \
                       "üîÑ <b>Bot ƒê·ªông Th√¥ng minh</b>\n‚Ä¢ T·ª± ƒë·ªông t√¨m coin\n‚Ä¢ ƒêa chi·∫øn l∆∞·ª£c\n\n" \
                       "üéØ <b>Reverse 24h</b>\n‚Ä¢ ƒê·∫£o chi·ªÅu bi·∫øn ƒë·ªông\n\n" \
                       "‚ö° <b>Scalping</b>\n‚Ä¢ Giao d·ªãch t·ªëc ƒë·ªô cao\n\n" \
                       "üõ°Ô∏è <b>Safe Grid</b>\n‚Ä¢ Grid an to√†n\n\n" \
                       "üìà <b>Trend Following</b>\n‚Ä¢ Theo xu h∆∞·ªõng"
        
        send_telegram(strategy_info, chat_id,
                     bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)

    def _handle_config(self, chat_id):
        balance = self.get_cached_balance()
        api_status = "‚úÖ ƒê√£ k·∫øt n·ªëi" if balance is not None else "‚ùå L·ªói k·∫øt n·ªëi"
        
        config_info = (
            f"‚öôÔ∏è <b>C·∫§U H√åNH H·ªÜ TH·ªêNG</b>\n\n"
            f"üîë Binance API: {api_status}\n"
            f"ü§ñ T·ªïng s·ªë bot: {len(self.bots)}\n"
            f"üîÑ Bot ƒë·ªông: {sum(1 for b in self.bots.values() if getattr(b, 'dynamic_mode', False))}\n"
            f"üåê WebSocket: {len(self.ws_manager.connections)} k·∫øt n·ªëi"
        )
        send_telegram(config_info, chat_id,
                     bot_token=self.telegram_bot_token, default_chat_id=self.telegram_chat_id)

# ==============================================================
